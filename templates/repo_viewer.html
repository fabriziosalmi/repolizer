<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Repolizer - Home</title>
    
    <!-- Web App Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Repolizer">
    <meta name="theme-color" content="#1f2937">
    <meta name="application-name" content="Repolizer">
    <meta name="msapplication-TileColor" content="#1f2937">
    <meta name="msapplication-navbutton-color" content="#1f2937">
    
    <!-- App Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="/static/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/icons/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/icons/apple-touch-icon.png">
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Add specific styles for iOS web app */
        @media (display-mode: standalone) {
            body {
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
        }
        
        /* Existing styles */
        .repo-card {
            transition: all 0.3s ease;
            position: relative;
            background-color: white;
            border-radius: 0.5rem; /* Match the Tailwind rounded-lg class (8px) */
            outline: 2px solid transparent;
            outline-offset: -1px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        /* Simple outline animation for card hover */
        .repo-card:hover {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            transform: none;
            outline: 2px solid #3b82f6; /* Blue-500 */
            border-radius: 0.5rem;
            outline-color: #3b82f6; /* Blue-500 */
            
            /* Add browser-specific animation if needed */
            animation: outlineGradient 2s linear infinite;
            -webkit-animation: outlineGradient 2s linear infinite;
        }
        
        @keyframes outlineGradient {
            0% { outline-color: #4ade80; } /* green-400 */
            25% { outline-color: #3b82f6; } /* blue-500 */
            50% { outline-color: #a855f7; } /* purple-500 */
            75% { outline-color: #f43f5e; } /* rose-500 */
            100% { outline-color: #4ade80; } /* green-400 */
        }
        
        @-webkit-keyframes outlineGradient {
            0% { outline-color: #4ade80; } /* green-400 */
            25% { outline-color: #3b82f6; } /* blue-500 */
            50% { outline-color: #a855f7; } /* purple-500 */
            75% { outline-color: #f43f5e; } /* rose-500 */
            100% { outline-color: #4ade80; } /* green-400 */
        }
        
        /* Remove previous pseudo-elements */
        .repo-card::before, .repo-card::after {
            content: none;
        }
        
        .score-bar {
            height: 20px;
            border-radius: 9999px;
            position: relative;
            overflow: hidden;
            background-color: #e5e7eb;
        }
        .score-bar-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            border-radius: 9999px;
            transition: width 0.5s ease;
        }
        /* Score color gradients */
        .score-high {
            background-color: #34d399;
            background-image: linear-gradient(to right, #4ade80, #34d399, #4ade80);
        }
        .score-medium {
            background-color: #fbbf24;
            background-image: linear-gradient(to right, #fcd34d, #fbbf24, #fcd34d);
        }
        .score-low {
            background-color: #f87171;
            background-image: linear-gradient(to right, #fb7185, #f87171, #fb7185);
        }
        
        /* Category gradients for vertical bars */
        .category-bar-gradient-high {
            background-image: linear-gradient(to top, rgba(167, 243, 208, 0.8), rgba(52, 211, 153, 1), rgba(167, 243, 208, 0.8));
        }
        .category-bar-gradient-medium {
            background-image: linear-gradient(to top, rgba(253, 230, 138, 0.8), rgba(251, 191, 36, 1), rgba(253, 230, 138, 0.8));
        }
        .category-bar-gradient-low {
            background-image: linear-gradient(to top, rgba(254, 202, 202, 0.8), rgba(248, 113, 113, 1), rgba(254, 202, 202, 0.8));
        }
        
        /* Border gradients */
        .border-gradient {
            position: relative;
        }
        .border-gradient::before {
            content: '';
            position: absolute;
            inset: 0;
            padding: 1px; /* Border width */
            border-radius: inherit;
            background: linear-gradient(to right, transparent, currentColor, transparent);
            -webkit-mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            pointer-events: none;
        }
        .border-left-gradient {
            position: relative;
        }
        .border-left-gradient::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            width: 4px;
            background: linear-gradient(to bottom, transparent, currentColor 50%, transparent);
        }
        /* Category badge styles */
        .category-badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            display: inline-block;
            margin-right: 0.25rem;
            margin-bottom: 0.25rem;
        }
        /* Add loading indicator style */
        #loading-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 4rem 0;
            font-size: 1.2rem;
            color: #4b5563; /* gray-600 */
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #3b82f6; /* blue-500 */
            animation: spin 1s ease infinite;
            margin-right: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Style for no results */
        #no-results {
            text-align: center;
            padding: 4rem 0;
            color: #6b7280; /* gray-500 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <header class="bg-gray-800 text-white shadow-lg">
        <div class="container mx-auto p-4 flex flex-col md:flex-row justify-between items-center">
            <div class="flex items-center mb-4 md:mb-0">
                <i class="fab fa-github text-4xl mr-3"></i>
                <h1 class="text-2xl font-bold">Repolizer</h1>
            </div>
            <!-- Updated navigation menu -->
            <div class="flex items-center space-x-4">
                <a href="/" class="text-blue-300 border-b-2 border-blue-300"> <!-- Active link style -->
                    <i class="fas fa-home mr-1"></i> Home
                </a>
                {% if current_user.is_authenticated %}
                    <a href="/scraper" class="text-white hover:text-blue-300 transition-colors">
                        <i class="fas fa-search mr-1"></i> Scraper
                    </a>
                    <a href="/analyze" class="text-white hover:text-blue-300 transition-colors">
                        <i class="fas fa-chart-line mr-1"></i> Analyzer
                    </a>
                {% endif %}
                <a href="/stats" class="text-white hover:text-blue-300 transition-colors">
                    <i class="fas fa-chart-pie mr-1"></i> Statistics
                </a>
                <!-- Login/Logout Link -->
                {% if current_user.is_authenticated %}
                    <a href="{{ url_for('logout') }}" class="text-white hover:text-red-400 transition-colors">
                        <i class="fas fa-sign-out-alt mr-1"></i> Logout
                    </a>
                {% else %}
                    <a href="{{ url_for('login') }}" class="text-white hover:text-blue-300 transition-colors">
                        <i class="fas fa-sign-in-alt mr-1"></i> Login
                    </a>
                {% endif %}
            </div>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <!-- Updated search/sort/filter controls - all in one row -->
        <div class="mb-6 bg-white rounded-lg shadow-md p-4">
            <div class="flex flex-wrap items-center gap-2">
                <!-- Search input - adaptive width -->
                <div class="relative w-full sm:w-64 lg:w-72">
                    <input id="search-input" type="text" placeholder="Search repositories..."
                           class="px-4 py-2 rounded-lg bg-gray-100 text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500 w-full">
                    <i class="fas fa-search absolute right-3 top-3 text-gray-400"></i>
                </div>
                
                <!-- Sort dropdown -->
                <select id="sort-select" class="px-4 py-2 rounded-lg bg-gray-100 text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500 w-full sm:w-auto">
                    <option value="overall_score_desc">Sort by Overall Score (High to Low)</option>
                    <option value="overall_score_asc">Sort by Overall Score (Low to High)</option>
                    <option value="stars">Sort by Stars</option>
                    <option value="forks">Sort by Forks</option>
                    <option value="updated">Sort by Updated</option>
                    <option value="name">Sort by Name</option>
                </select>

                <!-- Filters now on same line -->
                <div class="flex items-center flex-wrap gap-2">
                    <span class="text-xs text-gray-600 font-medium hidden sm:inline">Filters:</span>
                    
                    <!-- Language Filter Dropdown -->
                    <select id="language-filter-select" class="px-4 py-2 rounded-lg bg-gray-100 text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500 w-full sm:w-auto">
                        <option value="all">All Languages</option>
                        <option value="Python">Python</option>
                        <option value="JavaScript">JavaScript</option>
                        <option value="Java">Java</option>
                        <option value="Go">Go</option>
                        <option value="TypeScript">TypeScript</option>
                    </select>

                    <!-- Removed Category Filter Dropdown -->

                    <!-- Min Score Filter Dropdown - Updated values -->
                    <select id="score-filter-select" class="px-4 py-2 rounded-lg bg-gray-100 text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500 w-full sm:w-auto">
                        <option value="0">Min Score: 0+</option>
                        <option value="40">Min Score: 40+</option>
                        <option value="70">Min Score: 70+</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="mb-6 flex justify-between items-center"> <!-- Simple container for title and count -->
            <h2 class="text-xl font-bold text-gray-800">Repository Health Analysis</h2>
            <div class="text-sm text-gray-600">
                <span id="repo-count" class="font-semibold">0</span> repositories found
            </div>
        </div>

        <div id="loading-indicator">
            <div class="spinner"></div>
            <span>Loading repositories...</span>
        </div>

        <div id="repo-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Repository cards will be dynamically inserted here -->
        </div>

        <div id="no-results" class="hidden">
            <i class="fas fa-search text-gray-400 text-5xl mb-4"></i>
            <p class="text-xl text-gray-600">No repositories found matching your search criteria.</p>
        </div>
    </main>

    <footer class="bg-gray-800 text-white mt-auto py-6">
        <div class="container mx-auto px-4 text-center">
            <p>&copy; {{ current_year }} Repolizer</p> <!-- Use context variable -->
        </div>
    </footer>

    <script>
  document.addEventListener('DOMContentLoaded', async () => {
    // Global variables
    let allRepos = [];
    let filteredRepos = [];
    let currentLanguage = 'all';
    let minScoreFilter = 0;
    let currentPage = 1;
    const reposPerPage = 30;
    
    // Get elements from the DOM
    const reposContainer = document.getElementById('repo-grid');
    const loadingIndicator = document.getElementById('loading-indicator');
    const noResults = document.getElementById('no-results');
    const repoCount = document.getElementById('repo-count');
    const searchInput = document.getElementById('search-input');
    const sortSelect = document.getElementById('sort-select');
    const languageFilterSelect = document.getElementById('language-filter-select');
    const scoreFilterSelect = document.getElementById('score-filter-select');
    
    // Create pagination container at the bottom of the page
    const paginationContainer = document.createElement('div');
    paginationContainer.id = 'pagination-container';
    paginationContainer.className = 'flex justify-center my-6';
    reposContainer.parentNode.insertBefore(paginationContainer, reposContainer.nextSibling);

    // Check if all required DOM elements exist
    if (!reposContainer || !loadingIndicator || !noResults || !repoCount) {
      console.error('Required DOM elements not found.');
      return;
    }

    // Category icons and names
    const categoryIcons = {
      'documentation': 'fa-file-lines',
      'security': 'fa-shield-alt',
      'code_quality': 'fa-code',
      'performance': 'fa-tachometer-alt',
      'accessibility': 'fa-universal-access',
      'ci_cd': 'fa-sync',
      'maintainability': 'fa-wrench',
      'testing': 'fa-vial',
      'licensing': 'fa-balance-scale',
      'community': 'fa-users'
    };

    const categoryNames = {
      'documentation': 'Documentation',
      'security': 'Security',
      'code_quality': 'Code Quality',
      'performance': 'Performance',
      'accessibility': 'Accessibility',
      'ci_cd': 'CI/CD',
      'maintainability': 'Maintainability',
      'testing': 'Testing',
      'licensing': 'Licensing',
      'community': 'Community'
    };

    // Get result path from parameters or use default
    const urlParams = new URLSearchParams(window.location.search);
    const resultPath = urlParams.get('path') || 'results.jsonl';
    const pageParam = urlParams.get('page');
    if (pageParam) {
      currentPage = parseInt(pageParam, 10) || 1;
    }
    
    console.log(`Loading repositories from: ${resultPath}, page ${currentPage}`);

    // Load repositories from the results file
    try {
      // Show loading indicator
      if (loadingIndicator) {
        loadingIndicator.style.display = 'flex';
        loadingIndicator.classList.remove('hidden');
      }
      
      if (noResults) {
        noResults.classList.add('hidden');
      }
      
      // First try the specified results file
      const response = await fetch(resultPath);

      if (!response.ok) {
        throw new Error(`Failed to fetch ${resultPath}: ${response.status} ${response.statusText}`);
      }

      const text = await response.text();

      if (!text || text.trim() === '') {
        throw new Error(`No data in ${resultPath}`);
      }

      console.log(`Loaded file with ${text.length} characters`);

      // Determine if the file is JSON or JSONL format
      const isJson = resultPath.toLowerCase().endsWith('.json') || 
                     (text.trim().startsWith('[') && text.trim().endsWith(']'));

      console.log(`Detected file format: ${isJson ? 'JSON' : 'JSONL'}`);

      // Use a dictionary to store the latest entry for each repo ID
      const repoDataMap = {};

      if (isJson) {
        // Handle JSON format (array of objects)
        try {
          const jsonData = JSON.parse(text);
          const repos = Array.isArray(jsonData) ? jsonData : (jsonData && jsonData.repository ? [jsonData] : []);

          repos.forEach(parsedRepo => {
            if (parsedRepo && parsedRepo.repository && parsedRepo.repository.id) {
              // Store the latest entry (or only entry) for this ID
              repoDataMap[parsedRepo.repository.id] = parsedRepo;
            }
          });
        } catch (e) {
          console.error('Error parsing JSON:', e);
          throw new Error('Invalid JSON format');
        }
      } else {
        // Handle JSONL format (one JSON object per line)
        const lines = text.split('\n').filter(line => line.trim() !== '');
        console.log(`Processing ${lines.length} lines of JSONL`);

        for (const line of lines) {
          try {
            const parsedRepo = JSON.parse(line);
            if (parsedRepo && parsedRepo.repository && parsedRepo.repository.id) {
              // Store the latest entry for this ID, overwriting previous ones
              repoDataMap[parsedRepo.repository.id] = parsedRepo;
            }
          } catch (e) {
            console.warn('Error parsing line:', line.substring(0, 100) + '...', e);
            // Continue to next line
          }
        }
      }

      // Convert the map values back to an array
      allRepos = Object.values(repoDataMap);

      console.log(`Total unique repositories loaded (before filtering): ${allRepos.length}`);

      // Fallback logic remains the same...
      if (allRepos.length === 0 && resultPath !== 'repositories.jsonl') { // Avoid infinite loop if fallback fails
        console.log("No repositories found in the results file. Trying repositories.jsonl as fallback.");
        // ... (rest of fallback logic using repositories.jsonl) ...
        // Note: Fallback currently doesn't deduplicate, might need adjustment if duplicates exist there too.
        try {
            const fallbackResponse = await fetch('repositories.jsonl');
            if (fallbackResponse.ok) {
                const fallbackText = await fallbackResponse.text();
                if (fallbackText.trim()) {
                    const fallbackLines = fallbackText.split('\n').filter(line => line.trim() !== '');
                    const fallbackRepoMap = {}; // Use map for fallback deduplication too
                    for (const line of fallbackLines) {
                        try {
                            const rawRepo = JSON.parse(line);
                            if (rawRepo && rawRepo.id) { // Assuming fallback has ID
                                // Convert to results format and store latest
                                fallbackRepoMap[rawRepo.id] = {
                                    repository: rawRepo,
                                    overall_score: 0, // Default score for raw repo data
                                    timestamp: new Date().toISOString()
                                    // Add other default fields if needed
                                };
                            }
                        } catch (e) {
                            console.warn('Error parsing fallback line:', e);
                        }
                    }
                    allRepos = Object.values(fallbackRepoMap); // Replace allRepos with fallback data
                    console.log(`Loaded ${allRepos.length} unique repositories from fallback repositories.jsonl.`);
                    console.log(`Total unique repositories loaded from fallback (before filtering): ${allRepos.length}`);
                }
            } else {
                console.log("No fallback repository data found either.");
            }
        } catch (fallbackError) {
             console.error("Error fetching or processing fallback repositories.jsonl:", fallbackError);
        }
      }


      // Process each repo to calculate category averages
      allRepos.forEach(repo => {
        // Add category averages
        repo.category_scores = {};

        // For each category, calculate average score
        Object.keys(categoryNames).forEach(category => {
          if (repo[category]) {
            const checks = Object.values(repo[category]).filter(check => 
              typeof check === 'object' && check !== null && 'score' in check
            );
            
            if (checks.length > 0) {
              const sum = checks.reduce((total, check) => total + (check.score || 0), 0);
              repo.category_scores[category] = parseFloat((sum / checks.length).toFixed(1));
            } else {
              repo.category_scores[category] = 0;
            }
          } else {
            repo.category_scores[category] = 0;
          }
        });
      });

      filteredRepos = [...allRepos];
      
      if (repoCount) {
        repoCount.textContent = filteredRepos.length;
      }

      // Initial sort by overall score
      sortRepos('overall_score_desc');

      // Hide loading indicator
      if (loadingIndicator) {
        loadingIndicator.style.display = 'none';
        loadingIndicator.classList.add('hidden');
      }

      // Check if there are results to display
      if (filteredRepos.length === 0) {
        if (noResults) {
          noResults.classList.remove('hidden');
        }
      } else {
         if (noResults) { // Ensure no-results is hidden if we have data
            noResults.classList.add('hidden');
         }
        // updatePagination(); // Called within filterRepos/sortRepos -> displayRepos
      }

    } catch (error) {
      console.error('Error loading repositories:', error);
      
      // Ensure the loading indicator is hidden
      if (loadingIndicator) {
        loadingIndicator.style.display = 'none';
        loadingIndicator.classList.add('hidden');
      }
      
      if (noResults) {
        noResults.classList.remove('hidden');
        
        const errorMsg = noResults.querySelector('p');
        if (errorMsg) {
          errorMsg.textContent = `Error loading repository data: ${error.message}`;
        }
      }
    }

    // Event listener for search input
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        filterRepos();
      });
    }

    // Event listener for sort select
    if (sortSelect) {
      sortSelect.addEventListener('change', () => {
        sortRepos(sortSelect.value);
      });
    }

    // Event listener for language filter select
    if (languageFilterSelect) {
      languageFilterSelect.addEventListener('change', () => {
        currentLanguage = languageFilterSelect.value;
        filterRepos();
      });
    }

    // Event listener for score filter select
    if (scoreFilterSelect) {
      scoreFilterSelect.addEventListener('change', () => {
        minScoreFilter = parseInt(scoreFilterSelect.value);
        filterRepos();
      });
    }

    // Function to filter repositories
    function filterRepos() {
      const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';

      console.log(`Filtering repos with: Search="${searchTerm}", Language=${currentLanguage}, MinScore=${minScoreFilter}`);
      console.log(`Total unique repos available for filtering: ${allRepos.length}`);

      filteredRepos = allRepos.filter(repo => {
        // Filter by search term (repo name or description)
        const nameMatch = repo.repository?.name?.toLowerCase().includes(searchTerm) ||
          (repo.repository?.description && repo.repository.description.toLowerCase().includes(searchTerm));

        // Filter by language
        const languageMatch = currentLanguage === 'all' || repo.repository?.language === currentLanguage;

        // Filter by overall score
        const scoreMatch = (repo.overall_score || 0) >= minScoreFilter;

        return nameMatch && languageMatch && scoreMatch;
      });

      console.log(`Total repos after filtering: ${filteredRepos.length}`);

      // Reset to first page when filters change
      currentPage = 1;
      updatePagination();
      
      // Update count and display repositories
      if (repoCount) {
        repoCount.textContent = filteredRepos.length;
      }
      
      displayRepos();
    }

    // Function to sort repositories
    function sortRepos(sortBy) {
      switch (sortBy) {
        case 'overall_score_desc':
          filteredRepos.sort((a, b) => (b.overall_score || 0) - (a.overall_score || 0));
          break;
        case 'overall_score_asc':
          filteredRepos.sort((a, b) => (a.overall_score || 0) - (b.overall_score || 0));
          break;
        case 'stars':
          filteredRepos.sort((a, b) => (b.repository?.stargazers_count || 0) - (a.repository?.stargazers_count || 0));
          break;
        case 'forks':
          filteredRepos.sort((a, b) => (b.repository?.forks_count || 0) - (a.repository?.forks_count || 0));
          break;
        case 'updated':
          filteredRepos.sort((a, b) => {
            const dateA = a.repository?.updated_at ? new Date(a.repository.updated_at) : new Date(0);
            const dateB = b.repository?.updated_at ? new Date(b.repository.updated_at) : new Date(0);
            return dateB - dateA;
          });
          break;
        case 'name':
          filteredRepos.sort((a, b) => {
            const nameA = a.repository?.name?.toLowerCase() || '';
            const nameB = b.repository?.name?.toLowerCase() || '';
            return nameA.localeCompare(nameB);
          });
          break;
      }

      displayRepos();
    }

    // Function to display repositories with pagination
    function displayRepos() {
      if (!reposContainer) return;
      
      // Clear the container
      reposContainer.innerHTML = '';

      if (filteredRepos.length === 0) {
        if (noResults) {
          noResults.classList.remove('hidden');
        }
        return;
      }

      if (noResults) {
        noResults.classList.add('hidden');
      }

      // Calculate pagination
      const startIndex = (currentPage - 1) * reposPerPage;
      const endIndex = Math.min(startIndex + reposPerPage, filteredRepos.length);
      const currentPageRepos = filteredRepos.slice(startIndex, endIndex);

      // Display the current page repositories
      currentPageRepos.forEach(repo => {
        if (!repo.repository) {
          console.warn('Repository object is missing required data:', repo);
          return;
        }
        
        const card = createRepoCard(repo);
        reposContainer.appendChild(card);
      });
      
      // Update pagination controls
      updatePagination();
    }

    // Function to update pagination controls
    function updatePagination() {
      const totalPages = Math.ceil(filteredRepos.length / reposPerPage);
      
      // Clear previous pagination
      paginationContainer.innerHTML = '';
      
      if (totalPages <= 1) {
        return; // No pagination needed
      }
      
      // Create pagination controls
      const pagination = document.createElement('div');
      pagination.className = 'flex items-center space-x-1';
      
      // Previous button
      const prevButton = document.createElement('button');
      prevButton.className = 'px-4 py-2 border rounded-md ' + 
        (currentPage === 1 ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-white text-blue-600 hover:bg-blue-50');
      prevButton.innerHTML = '<i class="fas fa-chevron-left"></i>';
      prevButton.disabled = currentPage === 1;
      prevButton.addEventListener('click', () => {
        if (currentPage > 1) {
          currentPage--;
          displayRepos();
        }
      });
      pagination.appendChild(prevButton);
      
      // Page numbers
      const maxVisiblePages = 5;
      let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
      let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
      
      // Adjust if we're at the end
      if (endPage - startPage + 1 < maxVisiblePages) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
      }
      
      // First page button if not visible
      if (startPage > 1) {
        const firstButton = document.createElement('button');
        firstButton.className = 'px-4 py-2 border rounded-md bg-white text-blue-600 hover:bg-blue-50';
        firstButton.textContent = '1';
        firstButton.addEventListener('click', () => {
          currentPage = 1;
          displayRepos();
        });
        pagination.appendChild(firstButton);
        
        // Ellipsis if needed
        if (startPage > 2) {
          const ellipsis = document.createElement('span');
          ellipsis.className = 'px-4 py-2';
          ellipsis.textContent = '...';
          pagination.appendChild(ellipsis);
        }
      }
      
      // Page buttons
      for (let i = startPage; i <= endPage; i++) {
        const pageButton = document.createElement('button');
        pageButton.className = 'px-4 py-2 border rounded-md ' + 
          (i === currentPage ? 'bg-blue-600 text-white' : 'bg-white text-blue-600 hover:bg-blue-50');
        pageButton.textContent = i.toString();
        pageButton.addEventListener('click', () => {
          currentPage = i;
          displayRepos();
        });
        pagination.appendChild(pageButton);
      }
      
      // Last page button if not visible
      if (endPage < totalPages) {
        // Ellipsis if needed
        if (endPage < totalPages - 1) {
          const ellipsis = document.createElement('span');
          ellipsis.className = 'px-4 py-2';
          ellipsis.textContent = '...';
          pagination.appendChild(ellipsis);
        }
        
        const lastButton = document.createElement('button');
        lastButton.className = 'px-4 py-2 border rounded-md bg-white text-blue-600 hover:bg-blue-50';
        lastButton.textContent = totalPages.toString();
        lastButton.addEventListener('click', () => {
          currentPage = totalPages;
          displayRepos();
        });
        pagination.appendChild(lastButton);
      }
      
      // Next button
      const nextButton = document.createElement('button');
      nextButton.className = 'px-4 py-2 border rounded-md ' + 
        (currentPage === totalPages ? 'bg-gray-100 text-gray-400 cursor-not-allowed' : 'bg-white text-blue-600 hover:bg-blue-50');
      nextButton.innerHTML = '<i class="fas fa-chevron-right"></i>';
      nextButton.disabled = currentPage === totalPages;
      nextButton.addEventListener('click', () => {
        if (currentPage < totalPages) {
          currentPage++;
          displayRepos();
        }
      });
      pagination.appendChild(nextButton);
      
      // Page info
      const pageInfo = document.createElement('div');
      pageInfo.className = 'ml-4 text-sm text-gray-600';
      pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${filteredRepos.length} matching repositories)`;
      
      // Append to container
      paginationContainer.appendChild(pagination);
      paginationContainer.appendChild(pageInfo);
      
      // Update URL with current page
      const url = new URL(window.location.href);
      url.searchParams.set('page', currentPage);
      window.history.replaceState({}, '', url);
    }

    // Function to create a repository card (Updated Button Section)
    function createRepoCard(repo) {
      const card = document.createElement('div');
      card.className = 'repo-card bg-white rounded-lg shadow-md overflow-hidden h-full flex flex-col transition-all duration-300 ease-in-out hover:shadow-lg';

      const repoData = repo.repository || {};
      const repoId = repoData.id || '';

      // ... (rest of the card creation logic: stars, forks, description, chart, score bar) ...
      const stars = formatNumber(repoData.stargazers_count || 0);
      const forks = formatNumber(repoData.forks_count || 0);
      const updatedAt = repoData.updated_at ? formatDate(repoData.updated_at) : 'unknown';
      const description = repoData.description
        ? truncateText(repoData.description, 120)
        : 'No description available';
      const languageColor = getLanguageColor(repoData.language);
      const languageBadge = repoData.language ?
        `<span class="inline-flex items-center">
            <span class="w-3 h-3 rounded-full mr-1" style="background-color: ${languageColor}"></span>
            ${repoData.language}
          </span>` : '';
      const overallScore = repo.overall_score || 0;
      const scoreColorClass = overallScore >= 70 ? 'text-green-600' : (overallScore >= 40 ? 'text-yellow-600' : 'text-red-600');
      const scoreBarFillClass = overallScore >= 70 ? 'score-high' : (overallScore >= 40 ? 'score-medium' : 'score-low');

      // --- Category Bar Chart ---
      let categoryBarChartHtml = `
        <div class="category-bar-chart flex justify-between items-end h-24 mt-2 mb-3 px-1" style="margin-top: 2.5rem;">
      `;
      const fixedCategoryOrder = [
        'documentation', 'security', 'code_quality', 'performance', 'accessibility',
        'testing', 'maintainability', 'ci_cd', 'licensing', 'community'
      ];
      for (const category of fixedCategoryOrder) {
        const score = repo.category_scores?.[category] || 0;
        const icon = categoryIcons[category] || 'fa-question-circle';
        const name = categoryNames[category] || category;
        let colorClass;
        let gradientClass;
        if (score >= 70) {
          colorClass = 'bg-green-500';
          gradientClass = 'category-bar-gradient-high';
        }
        else if (score >= 40) {
          colorClass = 'bg-yellow-500';
          gradientClass = 'category-bar-gradient-medium';
        }
        else {
          colorClass = 'bg-red-500';
          gradientClass = 'category-bar-gradient-low';
        }
        const heightPercentage = Math.max(5, score);
        categoryBarChartHtml += `
          <div class="flex flex-col items-center group" title="${name}: ${score.toFixed(1)}">
            <div class="relative w-5 h-20 bg-gray-200 rounded-t overflow-hidden" style="border-top-left-radius: 1rem; border-top-right-radius: 1rem; width: 1rem;">
              <div class="${colorClass} ${gradientClass} absolute bottom-0 w-full rounded-t transition-all duration-300" style="height: ${heightPercentage}%;"></div>
            </div>
            <span class="text-xs mt-1 text-gray-600">${Math.round(score)}</span>
            <i class="fas ${icon} text-gray-500 mt-1 group-hover:text-blue-500 transition-colors"></i>
          </div>
        `;
      }
      categoryBarChartHtml += `</div>`;
      // --- End Category Bar Chart ---


      card.innerHTML = `
        <div class="p-5 flex-grow">
          <div class="flex justify-between items-start mb-3">
            <div>
              <h3 class="text-lg font-bold text-gray-800">
                <a href="${repoData.html_url || '#'}" target="_blank" class="hover:text-blue-600 transition-colors">
                  ${repoData.name || 'Unnamed Repository'}
                </a>
              </h3>
              <p class="text-sm text-gray-600">${repoData.full_name || ''}</p>
            </div>
            <div class="flex items-center text-gray-600">
              <span class="flex items-center text-sm mr-3">
                <i class="fas fa-star text-yellow-400 mr-1"></i> ${stars}
              </span>
              <span class="flex items-center text-sm">
                <i class="fas fa-code-branch mr-1"></i> ${forks}
              </span>
            </div>
          </div>

          <p class="text-gray-700 mb-2 text-sm">${description}</p>

          <!-- Category Score Bar Chart -->
          ${categoryBarChartHtml}

          <div class="mb-4">
            <div class="flex justify-between items-center mb-1">
              <span class="text-sm font-medium text-gray-700">Repolizer score:</span>
              <span class="text-sm font-semibold ${scoreColorClass}">${overallScore.toFixed(1)}</span>
            </div>
            <div class="score-bar bg-gray-200">
              <div class="score-bar-fill ${scoreBarFillClass}" style="width: ${overallScore}%"></div>
            </div>
          </div>

          <!-- Refactored Report Buttons Section -->
          <div class="mt-6 border-t pt-4">
            <p class="text-center text-sm font-medium text-gray-700 mb-2" style="font-size: 1.1rem;  font-weight: normal; padding-bottom: 10px; olor: #575757;">View Report</p>
            <div class="flex justify-center space-x-3">
              <a href="/repo/${repoId}" title="Free Report"
                 class="inline-flex items-center justify-center px-4 py-2 bg-blue-100 hover:bg-blue-200 text-blue-700 font-bold rounded-lg shadow-sm text-sm" style="width: 35%; height: 4rem; font-size: 1.3rem; font-weight: normal;">
                <i class="fas fa-chart-bar mr-2"></i>
                Free
              </a>
              <button type="button" title="Full Report (Paid)"
                      class="open-modal-button inline-flex items-center justify-center px-4 py-2 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg shadow-sm text-sm" style="width: 60%; height: 4rem; font-size: 1.3rem; font-weight: bold;"
                      data-repo-id="${repoId}">
                <i class="fas fa-credit-card mr-2"></i>
                Full
              </button>
            </div>
          </div>
          <!-- End Refactored Report Buttons Section -->

        </div>
        <div class="bg-gray-50 px-5 py-3 flex justify-between items-center text-sm text-gray-600 border-t">
          <span class="flex items-center">
            <i class="far fa-calendar-alt mr-1"></i> Last updated: ${updatedAt}
          </span>
          ${languageBadge}
        </div>
      `;

      // Add event listener to the modal button (no change needed here)
      const fullReportButton = card.querySelector('.open-modal-button');
      if (fullReportButton) {
          fullReportButton.addEventListener('click', (event) => {
              const clickedRepoId = event.currentTarget.getAttribute('data-repo-id');
              const repoForModal = filteredRepos.find(r => String(r.repository?.id) === String(clickedRepoId));
              if (repoForModal) {
                  openModal(repoForModal);
              } else {
                  console.error("Could not find repository data for modal:", clickedRepoId);
                  alert("Error: Could not load repository details for the full report.");
              }
          });
      }

      return card;
    }

    // Function to format large numbers
    function formatNumber(num) {
      return num.toLocaleString();
    }

    // Function to truncate text
    function truncateText(text, maxLength) {
      if (!text) return '';
      if (text.length > maxLength) {
        return text.substring(0, maxLength) + '...';
      }
      return text;
    }

    // Function to format date
    function formatDate(dateString) {
      if (!dateString) return 'Unknown';
      
      try {
        const date = new Date(dateString);
        return date.toLocaleDateString();
      } catch (e) {
        console.warn('Invalid date:', dateString);
        return 'Invalid date';
      }
    }

    // Function to get language color
    function getLanguageColor(language) {
      const colors = {
        'JavaScript': '#f1e05a',
        'Python': '#3572a5',
        'HTML': '#e34c26',
        'CSS': '#563d7c',
        'Java': '#b07219',
        'TypeScript': '#2b7489',
        'Ruby': '#701516',
        'Go': '#00ADD8',
        'C#': '#178600',
        'C++': '#f34b7d',
        'PHP': '#4F5D95'
      };

      return colors[language] || '#8F8F8F';
    }
  });
</script>
</body>
</html>